<!DOCTYPE html>
<html lang="en">
<head>
<title>Python Requests - accessing web resources via HTTP</title>
<link rel="stylesheet" href="/cfg/style.css" type="text/css">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="keywords" content="Python, Requests, www, HTTP client, API, HTTP request, HTTP response">
<meta name="description" content="Python Requests tutorial introduces the Python Requests module. We grab data, post
data, stream data, and connect to secure web pages.">
<meta name="author" content="Jan Bodnar">


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-5536206-1', 'auto');
  ga('send', 'pageview');

</script>

</head>

<body>

<header>

<div>
<a href="/" title="Home">ZetCode</a>
</div>

<nav>
    <a title="All tutorials" href="/all/">All</a>
    <a title="Go tutorials" href="/all/#go">Go</a>
    <a title="Python tutorials" href="/all/#python">Python</a>
    <a title="C# tutorials" href="/all/#csharp">C#</a>
    <a title="Java tutorials" href="/all/#java">Java</a>
    <a title="JavaScript tutorials" href="/all/#js">JavaScript</a>
    <a title="Subscribe to ZetCode news" href="http://zetcode.us13.list-manage.com/subscribe?u=9def9ccd4c70dbbaf691f90fc&id=6556210f80">Subscribe</a>
</nav>

</header>

<div class="container">

<div class="ltow">
    
<div id="ebooks">

<h2 class="blu">Ebooks</h2>

<ul>
<li><a href="/ebooks/advancedpyqt5/">PyQt5 ebook</a></li>
<li><a href="/ebooks/tkinter/">Tkinter ebook</a></li>
<li><a href="/ebooks/sqlitepython/">SQLite Python</a></li>
<li><a href="/ebooks/advancedwxpython/">wxPython ebook</a></li>
<li><a href="/ebooks/windowsapi/">Windows API ebook</a></li>
<li><a href="/ebooks/advancedjavaswing/">Java Swing ebook</a></li>
<li><a href="/ebooks/javagames/">Java games ebook</a></li>
<li><a href="/ebooks/mysqljava/">MySQL Java ebook</a></li>
</ul>

</div>

</div>


<div class="content">

<h1>Python Requests</h1>

<p class="last_mod">
last modified November 29, 2021
</p>

<p>
In this tutorial, we show how to work with the Python Requests module. We grab data, post
data, stream data, and connect to secure web pages. In the examples, we use an online
service, an Nginx server, a Python HTTP server, and a flask application.
</p>

<p>
ZetCode has also a concise <a href="/lang/python/">Python tutorial</a>.
</p>


<p>
The <dfn>Hypertext Transfer Protocol (<abbr>HTTP</abbr>)</dfn> is an application protocol for distributed, collaborative,
hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web.
</p>

<div class="ad-top hor-fix-ad">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- horizontal-fixed-2020 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="2550114901"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<h2>Python requests</h2>

<p>
<code>Requests</code> is a simple and elegant Python HTTP library. It provides methods for accessing Web
resources via HTTP. 
</p>

<pre class="compact">
$ sudo service nginx start
</pre>

<p>
We run Nginx web server on localhost. Some of our examples
use <code>nginx</code> server.
</p>


<h2>Python requests version</h2>

<p>
The first program prints the version of the Requests library.
</p>

<div class="codehead">version.py</div>
<pre class="code">
#!/usr/bin/env python

import requests

print(requests.__version__)
print(requests.__copyright__)
</pre>

<p>
The program prints the version and copyright of Requests.
</p>

<pre class="compact">
$ ./version.py
2.21.0
Copyright 2018 Kenneth Reitz
</pre>

<p>
This is a sample output of the example.
</p>


<h2>Python requests reading a web page</h2>

<p>
The <code>get</code> method issues a GET request; it fetches documents
identified by the given URL.
</p>

<div class="codehead">read_webpage.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.get("http://www.webcode.me")

print(resp.text)
</pre>

<p>
The script grabs the content of the <code>www.webcode.me</code> web page.
</p>

<pre class="explanation">
resp = req.get("http://www.webcode.me")
</pre>

<p>
The <code>get</code> method returns a response object.
</p>

<pre class="explanation">
print(resp.text)
</pre>

<p>
The text attribute contains the content of the response, in Unicode.
</p>

<pre class="compact">
$ ./read_webpage.py
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;My html page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;p&gt;
        Today is a beautiful day. We go swimming and fishing.
    &lt;/p&gt;

    &lt;p&gt;
         Hello there. How are you?
    &lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
This is the output of the <code>read_webpage.py</code> script.
</p>

<p>
The following program gets a small web page and strips its HTML tags.
</p>

<div class="codehead">strip_tags.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req
import re

resp = req.get("http://www.webcode.me")

content = resp.text

stripped = re.sub('&lt;[^&lt;]+?&gt;', '', content)
print(stripped)
</pre>

<p>
The script strips the HTML tags of the <code>www.webcode.me</code>
web page.
</p>

<pre class="explanation">
stripped = re.sub('&lt;[^&lt;]+?&gt;', '', content)
</pre>

<p>
A simple regular expression is used to strip the HTML tags.
</p>


<h2>HTTP Request</h2>

<p>
An <dfn>HTTP request</dfn> is a message send from the client to the browser to
retrieve some information or to make some action.
</p>

<p>
<code>Request's</code> <code>request</code> method creates a new request.
Note that the <code>request</code> module has some higher-level methods,
such as <code>get</code>, <code>post</code>, or <code>put</code>,
which save some typing for us.
</p>

<div class="codehead">create_request.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.request(method='GET', url="http://www.webcode.me")
print(resp.text)
</pre>

<p>
The example creates a GET request and sends it to <code>http://www.webcode.me</code>.
</p>


<h2>Python requests getting status</h2>

<p>
The <code>Response</code> object contains a server's response to an HTTP request.
Its <code>status_code</code> attribute returns HTTP status code of the response, such
as 200 or 404.
</p>

<div class="codehead">get_status.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.get("http://www.webcode.me")
print(resp.status_code)

resp = req.get("http://www.webcode.me/news")
print(resp.status_code)
</pre>

<p>
We perform two HTTP requests with the <code>get</code> method
and check for the returned status.
</p>

<pre class="compact">
$ ./get_status.py
200
404
</pre>

<p>
200 is a standard response for successful HTTP requests and 404 tells that the requested
resource could not be found.
</p>


<h2>Python requests head method</h2>

<p>
The <code>head</code> method retrieves document headers.
The headers consist of fields, including date, server, content type,
or last modification time.
</p>

<div class="codehead">head_request.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.head("http://www.webcode.me")

print("Server: " + resp.headers['server'])
print("Last modified: " + resp.headers['last-modified'])
print("Content type: " + resp.headers['content-type'])
</pre>

<p>
The example prints the server, last modification time, and content type
of the <code>www.webcode.me</code> web page.
</p>

<pre class="compact">
$ ./head_request.py
Server: nginx/1.6.2
Last modified: Sat, 20 Jul 2019 11:49:25 GMT
Content type: text/html
</pre>

<p>
This is the output of the <code>head_request.py</code> program.
</p>


<h2>Python requests get method</h2>

<p>
The <code>get</code> method issues a GET request to the server.
The GET method requests a representation of the specified resource.
</p>

<p>
The <code>httpbin.org</code> is a freely available HTTP Request &amp; Response Service.
</p>

<div class="codehead">mget.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.get("https://httpbin.org/get?name=Peter")
print(resp.text)
</pre>

<p>
The script sends a variable with a value to the <code>httpbin.org</code>
server. The variable is specified directly in the URL.
</p>

<pre class="compact">
$ ./mget.py
{
  "args": {
    "name": "Peter"
  },
  "headers": {
    "Accept": "*/*",
    "Accept-Encoding": "gzip, deflate",
    "Host": "httpbin.org",
    "User-Agent": "python-requests/2.21.0"
  },
  ...
}
</pre>

<p>
This is the output of the example.
</p>

<div class="codehead">mget2.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

payload = {'name': 'Peter', 'age': 23}
resp = req.get("https://httpbin.org/get", params=payload)

print(resp.url)
print(resp.text)
</pre>

<p>
The <code>get</code> method takes a <code>params</code> parameter where
we can specify the query parameters.
</p>

<pre class="explanation">
payload = {'name': 'Peter', 'age': 23}
</pre>

<p>
The data is sent in a Python dictionary.
</p>

<pre class="explanation">
resp = req.get("https://httpbin.org/get", params=payload)
</pre>

<p>
We send a GET request to the <code>httpbin.org</code> site and
pass the data, which is specified in the <code>params</code> parameter.
</p>

<pre class="explanation">
print(resp.url)
print(resp.text)
</pre>

<p>
We print the URL and the response content to the console.
</p>

<pre class="compact">
$ ./mget2.py
http://httpbin.org/get?name=Peter&amp;age=23
{
  "args": {
    "age": "23",
    "name": "Peter"
  },
  "headers": {
    "Accept": "*/*",
    "Accept-Encoding": "gzip, deflate",
    "Host": "httpbin.org",
    "User-Agent": "python-requests/2.21.0"
  },
  ...
}
</pre>

<p>
This is the output of the example.
</p>


<h2>Python requests redirection</h2>

<p>
Redirection is a process of forwarding one URL to a different URL.
The HTTP response status code 301 Moved Permanently is used for permanent URL redirection;
302 Found for a temporary redirection.
</p>

<div class="codehead">redirect.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.get("https://httpbin.org/redirect-to?url=/")

print(resp.status_code)
print(resp.history)
print(resp.url)
</pre>

<p>
In the example, we issue a GET request to the <code>https://httpbin.org/redirect-to</code> page.
This page redirects to another page; redirect responses are stored in the
<code>history</code> attribute of the response.
</p>

<pre class="compact">
$ ./redirect.py
200
[&lt;Response [302]&gt;]
https://httpbin.org/
</pre>

<p>
A GET request to <code>https://httpbin.org/redirect-to</code> was 302 redirected to
<code>https://httpbin.org</code>.
</p>

<p>
In the second example, we do not follow a redirect.
</p>

<div class="codehead">redirect2.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.get("https://httpbin.org/redirect-to?url=/", allow_redirects=False)

print(resp.status_code)
print(resp.url)
</pre>

<p>
The <code>allow_redirects</code> parameter specifies whether the redirect
is followed; the redirects are followed by default.
</p>

<pre class="compact">
$ ./redirect2.py
302
https://httpbin.org/redirect-to?url=/
</pre>

<p>
This is the output of the example.
</p>

<h2>Redirect with nginx</h2>

<p>
In the next example, we show how to set up a page redirect in nginx server.
</p>

<pre class="compact">
location = /oldpage.html {

        return 301 /newpage.html;
}
</pre>

<p>
Add these lines to the nginx configuration file, which is located at
<code>/etc/nginx/sites-available/default</code> on Debian.
</p>

<pre class="compact">
$ sudo service nginx restart
</pre>

<p>
After the file has been edited, we must restart nginx to apply the
changes.
</p>

<div class="codehead">oldpage.html</div>
<pre class="code">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Old page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
This is old page
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
This is the <code>oldpage.html</code> file located in the nginx document root.
</p>

<div class="codehead">newpage.html</div>
<pre class="code">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;New page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
This is a new page
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
This is the <code>newpage.html</code>.
</p>

<div class="codehead">redirect3.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.get("http://localhost/oldpage.html")

print(resp.status_code)
print(resp.history)
print(resp.url)

print(resp.text)
</pre>

<p>
This script accesses the old page and follows the redirect. As we already mentioned,
Requests follows redirects by default.
</p>

<pre class="compact">
$ ./redirect3.py
200
(&lt;Response [301]&gt;,)
http://localhost/files/newpage.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;New page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
This is a new page
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
This is the output of the example.
</p>

<pre class="compact">
$ sudo tail -2 /var/log/nginx/access.log
127.0.0.1 - - [21/Jul/2019:07:41:27 -0400] "GET /oldpage.html HTTP/1.1" 301 184
"-" "python-requests/2.4.3 CPython/3.4.2 Linux/3.16.0-4-amd64"
127.0.0.1 - - [21/Jul/2019:07:41:27 -0400] "GET /newpage.html HTTP/1.1" 200 109
"-" "python-requests/2.4.3 CPython/3.4.2 Linux/3.16.0-4-amd64"
</pre>

<p>
As we can see from the <code>access.log</code> file, the request was redirected
to a new file name. The communication consisted of two GET requests.
</p>


<h2>User agent</h2>

<p>
In this section, we specify the name of the user agent. We create our
own Python HTTP server.
</p>

<div class="codehead">http_server.py</div>
<pre class="code">
#!/usr/bin/env python

from http.server import BaseHTTPRequestHandler, HTTPServer

class MyHandler(BaseHTTPRequestHandler):

    def do_GET(self):

        message = "Hello there"

        self.send_response(200)

        if self.path == '/agent':

            message = self.headers['user-agent']

        self.send_header('Content-type', 'text/html')
        self.end_headers()

        self.wfile.write(bytes(message, "utf8"))

        return


def main():

    print('starting server on port 8081...')

    server_address = ('127.0.0.1', 8081)
    httpd = HTTPServer(server_address, MyHandler)
    httpd.serve_forever()

main()
</pre>

<p>
We have a simple Python HTTP server.
</p>

<pre class="explanation">
if self.path == '/agent':

    message = self.headers['user-agent']
</pre>

<p>
If the path contains <code>'/agent'</code>, we return
the specified user agent.
</p>

<div class="codehead">user_agent.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

headers = {'user-agent': 'Python script'}

resp = req.get("http://localhost:8081/agent", headers=headers)
print(resp.text)
</pre>

<p>
This script creates a simple GET request to our Python HTTP server.
To add HTTP headers to a request, we pass in a dictionary to the
<code>headers</code> parameter.
</p>

<pre class="explanation">
headers = {'user-agent': 'Python script'}
</pre>

<p>
The header values are placed in a Python dictionary.
</p>

<pre class="explanation">
resp = req.get("http://localhost:8081/agent", headers=headers)
</pre>

<p>
The values are passed to the <code>headers</code> parameter.
</p>

<pre class="compact">
$ simple_server.py
starting server on port 8081...
</pre>

<p>
First, we start the server.
</p>

<pre class="compact">
$ ./user_agent.py
Python script
</pre>

<p>
Then we run the script. The server responded with the name of the agent that we
have sent with the request.
</p>


<h2>Python requests post value</h2>

<p>
The <code>post</code> method dispatches a POST request on the given
URL, providing the key/value pairs for the fill-in form content.
</p>


<div class="codehead">post_value.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

data = {'name': 'Peter'}

resp = req.post("https://httpbin.org/post", data)
print(resp.text)
</pre>

<p>
The script sends a request with a <code>name</code> key having <code>Peter</code> value.
The POST request is issued with the <code>post</code> method.
</p>

<pre class="compact">
$ ./post_value.py
{
  "args": {},
  "data": "",
  "files": {},
  "form": {
    "name": "Peter"
  },
  "headers": {
    "Accept": "*/*",
    "Accept-Encoding": "gzip, deflate",
    "Content-Length": "10",
    "Content-Type": "application/x-www-form-urlencoded",
    "Host": "httpbin.org",
    "User-Agent": "python-requests/2.21.0"
  },
  "json": null,
  ...
}
</pre>

<p>
This is the output of the <code>post_value.py</code> script.
</p>

<h2>Python requests upload image</h2>

<p>
In the following example, we are going to upload an image. We create
a web application with Flask.
</p>

<div class="codehead">app.py</div>
<pre class="code">
#!/usr/bin/env python

import os
from flask import Flask, request

app = Flask(__name__)

@app.route("/")
def home():
    return 'This is home page'

@app.route("/upload", methods=['POST'])
def handleFileUpload():

    msg = 'failed to upload image'

    if 'image' in request.files:

        photo = request.files['image']

        if photo.filename != '':

            photo.save(os.path.join('.', photo.filename))
            msg = 'image uploaded successfully'

    return msg

if __name__ == '__main__':
    app.run()
</pre>

<p>
This is a simple application with two endpoints. The <code>/upload</code>
endpoint checks if there is some image and saves it to the current directory.
</p>

<div class="codehead">upload_file.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

url = 'http://localhost:5000/upload'

with open('sid.jpg', 'rb') as f:

    files = {'image': f}

    r = req.post(url, files=files)
    print(r.text)
</pre>

<p>
We send the image to the Flask application. The file is specified
in the <code>files</code> attribute of the <code>post</code> method.
</p>


<h2>JSON</h2>

<p>
<dfn><abbr>JSON</abbr></dfn> (JavaScript Object Notation) is a lightweight
data-interchange format. It is easy for humans to read and write and for
machines to parse and generate.
</p>

<p>
JSON data is a collection of key/value pairs; in Python, it is realized by a dictionary.
</p>

<h3>Read JSON</h3>

<p>
In the first example, we read JSON data from a PHP script.
</p>

<div class="codehead">send_json.php</div>
<pre class="code">
&lt;?php

$data = [ 'name' =&gt; 'Jane', 'age' =&gt; 17 ];
header('Content-Type: application/json');

echo json_encode($data);
</pre>

<p>
The PHP script sends JSON data. It uses the <code>json_encode</code>
function to do the job.
</p>

<div class="codehead">read_json.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

resp = req.get("http://localhost/send_json.php")
print(resp.json())
</pre>

<p>
The <code>read_json.py</code> reads JSON data sent by the PHP script.
</p>

<pre class="explanation">
print(resp.json())
</pre>

<p>
The <code>json</code> method returns the json-encoded
content of a response, if any.
</p>

<pre class="compact">
$ ./read_json.py
{'age': 17, 'name': 'Jane'}
</pre>

<p>
This is the output of the example.
</p>

<h3>Send JSON</h3>

<p>
Next, we send JSON data to a PHP script from a Python script.
</p>

<div class="codehead">parse_json.php</div>
<pre class="code">
&lt;?php

$data = file_get_contents("php://input");

$json = json_decode($data , true);

foreach ($json as $key =&gt; $value) {

    if (!is_array($value)) {
        echo "The $key is $value\n";
    } else {
        foreach ($value as $key =&gt; $val) {
            echo "The $key is $value\n";
        }
    }
}
</pre>

<p>
This PHP script reads JSON data and sends back a message with
the parsed values.
</p>

<div class="codehead">send_json.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

data = {'name': 'Jane', 'age': 17}

resp = req.post("http://localhost/parse_json.php", json=data)
print(resp.text)
</pre>

<p>
This script sends JSON data to the PHP application and
reads its response.
</p>

<pre class="explanation">
data = {'name': 'Jane', 'age': 17}
</pre>

<p>
This is the data to be sent.
</p>

<pre class="explanation">
resp = req.post("http://localhost/parse_json.php", json=data)
</pre>

<p>
The dictionary containing JSON data is passed to the <code>json</code>
parameter.
</p>

<pre class="compact">
$ ./send_json.py
The name is Jane
The age is 17
</pre>

<p>
This is the example output.
</p>


<h2>Retrieving definitions from a dictionary</h2>

<p>
In the following example, we find definitions of a term
on the <a href="http://www.dictionary.com">www.dictionary.com</a>.
To parse HTML, we use the <code>lxml</code> module.
</p>

<pre class="compact">
$ pip install lxml
</pre>

<p>
We install the <code>lxml</code> module with
the <code>pip</code> tool.
</p>

<div class="codehead">get_term.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req
from lxml import html
import textwrap

term = "dog"

resp = req.get("http://www.dictionary.com/browse/" + term)
root = html.fromstring(resp.content)

for sel in root.xpath("//span[contains(@class, 'one-click-content')]"):

    if sel.text:

        s = sel.text.strip()

        if (len(s) > 3):

            print(textwrap.fill(s, width=50))
</pre>

<p>
In this script, we find the definitions of the term dog on <code>www.dictionary.com</code>.
The <code>lxml</code> module is used to parse the HTML code.
</p>

<div class="note">
<strong>Note:</strong> The tags that contain the definitions may change overnight.
In such case we would need to adapt the script.
</div>

<pre class="explanation">
from lxml import html
</pre>

<p>
The <code>lxml</code> module can be used to parse HTML.
</p>

<pre class="explanation">
import textwrap
</pre>

<p>
The <code>textwrap</code> module is used to wrap text to a certain width.
</p>

<pre class="explanation">
resp = req.get("http://www.dictionary.com/browse/" + term)
</pre>

<p>
To perform a search, we append the term at the end of the URL.
</p>

<pre class="explanation">
root = html.fromstring(resp.content)
</pre>

<p>
We need to use <code>resp.content</code> rather than <code>resp.text</code>
because <code>html.fromstring</code> implicitly expects bytes as input.
(The <code>resp.content</code> returns content in bytes whereas <code>resp.text</code>
as Unicode text.
</p>

<pre class="explanation">
for sel in root.xpath("//span[contains(@class, 'one-click-content')]"):

    if sel.text:

        s = sel.text.strip()

        if (len(s) > 3):

            print(textwrap.fill(s, width=50))
</pre>

<p>
We parse the content. The main definitions are located inside the <code>span</code> tag, which
has the <code>one-click-content</code> attribute.
We improve the formatting by removing excessive white space and stray
characters. The text width has maximum of 50 characters. Note that such parsing
is subject to change.
</p>

<pre class="compact">
$ ./get_term.py
a domesticated canid,
any carnivore of the dog family Canidae, having
prominent canine teeth and, in the wild state, a
long and slender muzzle, a deep-chested muscular
body, a bushy tail, and large, erect ears.
...
</pre>

<p>
This is a partial list of the definitions.
</p>


<h2>Python requests streaming requests</h2>

<p>
<dfn>Streaming</dfn> is transmitting a continuous flow of audio and/or video data
while earlier parts are being used. The <code>Requests.iter_lines</code> iterates over the response
data, one line at a time. Setting <code>stream=True</code> on the request avoids reading the content
at once into memory for large responses.
</p>

<div class="codehead">streaming.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

url = "https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf"

local_filename = url.split('/')[-1]

r = req.get(url, stream=True)

with open(local_filename, 'wb') as f:

    for chunk in r.iter_content(chunk_size=1024):

        f.write(chunk)
</pre>

<p>
The example streams a PDF file and writes it on the disk.
</p>

<pre class="explanation">
r = req.get(url, stream=True)
</pre>

<p>
Setting <code>stream</code> to <code>True</code> when making a request,
Requests cannot release the connection back to the pool unless we consume
all the data or call <code>Response.close</code>.
</p>

<pre class="explanation">
with open(local_filename, 'wb') as f:

    for chunk in r.iter_content(chunk_size=1024):

        f.write(chunk)
</pre>

<p>
We read the resource by 1 KB chunks and write them to a local file.
</p>


<h2>Python requests credentials</h2>

<p>
The <code>auth</code> parameter provides a basic HTTP authentication; it takes
a tuple of a name and a password to be used for a realm. A security realm
is a mechanism used for protecting web application resources.
</p>

<pre class="compact">
$ sudo apt-get install apache2-utils
$ sudo htpasswd -c /etc/nginx/.htpasswd user7
New password:
Re-type new password:
Adding password for user user7
</pre>

<p>
We use the <code>htpasswd</code> tool to create a user name and a password
for basic HTTP authentication.
</p>

<pre class="compact">
location /secure {

        auth_basic "Restricted Area";
        auth_basic_user_file /etc/nginx/.htpasswd;
}
</pre>

<p>
Inside the nginx <code>/etc/nginx/sites-available/default</code> configuration file,
we create a secured page. The name of the realm is "Restricted Area".
</p>

<div class="codehead">index.html</div>
<pre class="code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;title&gt;Secure page&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;p&gt;
This is a secure page.
&lt;/p&gt;

&lt;/body&gt;

&lt;/html&gt;
</pre>

<p>
Inside the <code>/usr/share/nginx/html/secure</code> directory, we have
this HTML file.
</p>

<div class="codehead">credentials.py</div>
<pre class="code">
#!/usr/bin/env python

import requests as req

user = 'user7'
passwd = '7user'

resp = req.get("http://localhost/secure/", auth=(user, passwd))
print(resp.text)
</pre>

<p>
The script connects to the secure webpage; it provides the user name
and the password necessary to access the page.
</p>

<pre class="compact">
$ ./credentials.py
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;title&gt;Secure page&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

&lt;p&gt;
This is a secure page.
&lt;/p&gt;

&lt;/body&gt;

&lt;/html&gt;
</pre>

<p>
With the right credentials, the <code>credentials.py</code> script returns
the secured page.
</p>

<p>
In this tutorial, we have worked with the Python Requests module.
</p>

<div class="ad-bot square-fix-ad">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- square-fixed-2020 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:250px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="6775384732"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<p>
List <a href="/all/#python">all Python tutorials</a>.
</p>

<!-- TODO sessions, cookies, CA certificats, SSL Cert verification, timeouts  -->



</div> <!-- content -->

<div class="rtow">

<div class="vert-ad">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- vertical-2020 -->
<ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-9706709751191532"
        data-ad-slot="5880603481"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
<script>
        (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<div class="square-fix-ad">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- square-fixed-2020 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:250px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="6775384732"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

</div>

</div> <!-- container -->

<footer>

<nav>
<a title="Home page" href="/">Home</a> 
<a title="Follow on Facebook" href="https://www.facebook.com/zetcode7/">Facebook</a>
<a title="Follow on Twitter" href="https://twitter.com/janbodnar">Twitter</a>
<a title="Visit Github" href="https://github.com/janbodnar">Github</a>
<a title="Subscribe to ZetCode news" href="http://zetcode.us13.list-manage.com/subscribe?u=9def9ccd4c70dbbaf691f90fc&id=6556210f80">Subscribe</a>
<a title="Privacy policy" href="/privacy">Privacy</a> 
</nav>

<div>
<span>&copy; 2007 - 2022 Jan Bodnar</span>
<span>admin(at)zetcode.com</span>
</div>

</footer>

</body>
</html>
